datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  password  Password?
  chatbots  Chatbot[]
  chats     Chat[] // the user's chats, might not need here, never going to call
}

model Password {
  hash   String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Chatbot {
  id                    String      @id @default(uuid())
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
  name                  String
  description           String?
  user                  User        @relation(fields: [userId], references: [id])
  userId                String
  chats                 Chat[]
  model                 Model?
  temperature           Float?
  maxTokens             Int?
  systemPrompt          String?
  introMessages         String[]
  sampleMessages        String[]
  assistantMessageColor String?
  userMessageColor      String?
  backgroundColor       String?
  inputPlaceholder      String?
  documents             Document[]
  embeddings            Embedding[]
}

model Chat {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User?     @relation(fields: [userId], references: [id])
  userId    String?
  chatbot   Chatbot   @relation(fields: [chatbotId], references: [id])
  chatbotId String
  messages  Message[]
  name     String? @default("Untitled Chat")
}


// RENAME THIS TO "Page"
// interface Page {
//   url: string;
//   content: string;
// }
model Document {
  id         String      @id @default(uuid())
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  name       String
  embeddings Embedding[]
  content    String
  chatbot    Chatbot     @relation(fields: [chatbotId], references: [id])
  chatbotId  String
}

// {
//       id: hash, // The ID of the vector is the hash of the document content
//       values: embedding, // The vector values are the OpenAI embeddings
//       metadata: {
//         // The metadata includes details about the document
//         chunk: doc.pageContent, // The chunk of text that the vector represents
//         text: doc.metadata.text as string, // The text of the document
//         url: doc.metadata.url as string, // The URL where the document was found
//         hash: doc.metadata.hash as string, // The hash of the document content
//       },
// }

// RENAME THIS TO "Vector"
model Embedding {
  id         String                      @id @default(uuid())
  createdAt  DateTime                    @default(now())
  embedding  Unsupported("vector(1536)")
  document   Document                    @relation(fields: [documentId], references: [id])
  documentId String
  chatbot    Chatbot                     @relation(fields: [chatbotId], references: [id])
  chatbotId  String
  content    String

  @@index(fields: [chatbotId])
}

model Message {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      Role 
  content   String
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)
  chatId String
}

enum Role {
  USER
  ASSISTANT
}

enum Model {
  GPT4
  GPT35
  GEMINI
  LLAMA2
}